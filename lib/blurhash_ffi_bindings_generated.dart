// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/blurhash_ffi.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class BlurhashFfiBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  BlurhashFfiBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  BlurhashFfiBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// encode : Returns the blurhash string for the given image
  /// This function returns a string containing the BlurHash. This memory is managed by the function, and you should not free it.
  /// It will be overwritten on the next call into the function, so be careful!
  /// Parameters :
  /// `xComponents` - The number of components in the X direction. Must be between 1 and 9. 3 to 5 is usually a good range for this.
  /// `yComponents` - The number of components in the Y direction. Must be between 1 and 9. 3 to 5 is usually a good range for this.
  /// `width` - The width in pixels of the supplied image.
  /// `height` - The height in pixels of the supplied image.
  /// `rgb` - A pointer to the pixel data. This is supplied in RGBA format, with 4 bytes per pixels.
  /// `bytesPerRow` - The number of bytes per row of the RGB pixel data.
  ffi.Pointer<ffi.Char> blurHashForPixels(
    int xComponents,
    int yComponents,
    int width,
    int height,
    ffi.Pointer<ffi.Uint8> rgb,
    int bytesPerRow,
  ) {
    return _blurHashForPixels(
      xComponents,
      yComponents,
      width,
      height,
      rgb,
      bytesPerRow,
    );
  }

  late final _blurHashForPixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Uint8>, ffi.Int64)>>('blurHashForPixels');
  late final _blurHashForPixels = _blurHashForPixelsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, int, int, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// decode : Returns the pixel array of the result image given the blurhash string,
  /// Parameters :
  /// blurhash : A string representing the blurhash to be decoded.
  /// width : Width of the resulting image
  /// height : Height of the resulting image
  /// punch : The factor to improve the contrast, default = 1
  /// nChannels : Number of channels in the resulting image array, 3 = RGB, 4 = RGBA
  /// Returns : A pointer to memory region where pixels are stored in (H, W, C) format
  ffi.Pointer<ffi.Uint8> decode(
    ffi.Pointer<ffi.Char> blurhash,
    int width,
    int height,
    int punch,
    int nChannels,
  ) {
    return _decode(
      blurhash,
      width,
      height,
      punch,
      nChannels,
    );
  }

  late final _decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int)>>('decode');
  late final _decode = _decodePtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Char>, int, int, int, int)>();

  /// decodeToArray : Decodes the blurhash and copies the pixels to pixelArray,
  /// This method is suggested if you use an external memory allocator for pixelArray.
  /// pixelArray should be of size : width * height * nChannels
  /// Parameters :
  /// blurhash : A string representing the blurhash to be decoded.
  /// width : Width of the resulting image
  /// height : Height of the resulting image
  /// punch : The factor to improve the contrast, default = 1
  /// nChannels : Number of channels in the resulting image array, 3 = RGB, 4 = RGBA
  /// pixelArray : Pointer to memory region where pixels needs to be copied.
  /// Returns : int, -1 if error 0 if successful
  int decodeToArray(
    ffi.Pointer<ffi.Char> blurhash,
    int width,
    int height,
    int punch,
    int nChannels,
    ffi.Pointer<ffi.Uint8> pixelArray,
  ) {
    return _decodeToArray(
      blurhash,
      width,
      height,
      punch,
      nChannels,
      pixelArray,
    );
  }

  late final _decodeToArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Pointer<ffi.Uint8>)>>('decodeToArray');
  late final _decodeToArray = _decodeToArrayPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// isValidBlurhash : Checks if the Blurhash is valid or not.
  /// Parameters :
  /// blurhash : A string representing the blurhash
  /// Returns : bool (true if it is a valid blurhash, else false)
  bool isValidBlurhash(
    ffi.Pointer<ffi.Char> blurhash,
  ) {
    return _isValidBlurhash(
      blurhash,
    );
  }

  late final _isValidBlurhashPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'isValidBlurhash');
  late final _isValidBlurhash =
      _isValidBlurhashPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// freePixelArray : Frees the pixel array
  /// Parameters :
  /// pixelArray : Pixel array pointer which will be freed.
  /// Returns : void (None)
  void freePixelArray(
    ffi.Pointer<ffi.Uint8> pixelArray,
  ) {
    return _freePixelArray(
      pixelArray,
    );
  }

  late final _freePixelArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint8>)>>(
          'freePixelArray');
  late final _freePixelArray =
      _freePixelArrayPtr.asFunction<void Function(ffi.Pointer<ffi.Uint8>)>();
}
